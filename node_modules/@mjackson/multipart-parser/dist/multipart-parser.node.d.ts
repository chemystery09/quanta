import Headers from '@mjackson/headers';
import * as http from 'node:http';
import { Readable } from 'node:stream';

declare class MultipartParseError extends Error {
    constructor(message: string);
}
declare class MaxHeaderSizeExceededError extends MultipartParseError {
    constructor(maxHeaderSize: number);
}
declare class MaxFileSizeExceededError extends MultipartParseError {
    constructor(maxFileSize: number);
}
type MultipartMessageSource = ReadableStream<Uint8Array> | Uint8Array | Iterable<Uint8Array> | AsyncIterable<Uint8Array>;
type MultipartPartHandler = (part: MultipartPart) => void | Promise<void>;
interface ParseMultipartOptions {
    boundary: string;
    maxHeaderSize?: number;
    maxFileSize?: number;
}
type MultipartParserOptions = Omit<ParseMultipartOptions, 'boundary'>;
/**
 * A parser for `multipart/*` HTTP messages.
 */
declare class MultipartParser {
    #private;
    boundary: string;
    maxHeaderSize: number;
    maxFileSize: number;
    constructor(boundary: string, options?: MultipartParserOptions);
    /**
     * Parse a stream/buffer multipart message and call the given handler for each part it contains.
     * Resolves when the parse is finished and all handlers resolve.
     */
    parse(message: MultipartMessageSource, handler: MultipartPartHandler): Promise<void>;
}
/**
 * A part of a `multipart/*` HTTP message.
 */
declare class MultipartPart {
    #private;
    constructor(header: Uint8Array, body: ReadableStream<Uint8Array>);
    /**
     * The content of this part as an `ArrayBuffer`.
     */
    arrayBuffer(): Promise<ArrayBuffer>;
    /**
     * The body of this part as a `ReadableStream<Uint8Array>`. In `multipart/form-data` messages, this is useful
     * for streaming the value of files that were uploaded using `<input type="file">` fields.
     */
    get body(): ReadableStream<Uint8Array>;
    /**
     * Whether the body of this part has been consumed.
     */
    get bodyUsed(): boolean;
    /**
     * The body of this part buffered into a single `Uint8Array`. In `multipart/form-data` messages, this is useful
     * for reading the value of files that were uploaded using `<input type="file">` fields.
     */
    bytes(): Promise<Uint8Array>;
    /**
     * The headers associated with this part.
     */
    get headers(): Headers;
    /**
     * True if this part originated from a file upload.
     */
    get isFile(): boolean;
    /**
     * The filename of the part, if it is a file upload.
     */
    get filename(): string | undefined;
    /**
     * The media type of the part.
     */
    get mediaType(): string | undefined;
    /**
     * The name of the part, usually the `name` of the field in the `<form>` that submitted the request.
     */
    get name(): string | undefined;
    /**
     * The body of the part as a string. In `multipart/form-data` messages, this is useful for reading the value
     * of parts that originated from `<input type="text">` fields.
     *
     * Note: Do not use this for binary data, use `await part.bytes()` or stream `part.body` directly instead.
     */
    text(): Promise<string>;
}

/**
 * Extracts the boundary string from a `multipart/*` content type.
 */
declare function getMultipartBoundary(contentType: string): string | null;

/**
 * Returns true if the given request is a multipart request.
 */
declare function isMultipartRequest(req: http.IncomingMessage): boolean;
/**
 * Parse a multipart Node.js request and yield each part as a `MultipartPart` object.
 */
declare function parseMultipartRequest(req: http.IncomingMessage, handler: MultipartPartHandler): Promise<void>;
declare function parseMultipartRequest(req: http.IncomingMessage, options: MultipartParserOptions, handler: MultipartPartHandler): Promise<void>;
/**
 * Parse a multipart Node.js `Buffer` or `Readable` stream and yield each part as a `MultipartPart` object.
 *
 * Note: This is a low-level API that requires manual handling of the stream and boundary. If you're
 * building a web server, consider using `parseMultipartRequest(request)` instead.
 */
declare function parseMultipart(message: Readable | Buffer | Iterable<Buffer> | AsyncIterable<Buffer>, options: ParseMultipartOptions, handler: MultipartPartHandler): Promise<void>;

export { MaxFileSizeExceededError, MaxHeaderSizeExceededError, MultipartParseError, MultipartParser, type MultipartParserOptions, MultipartPart, type ParseMultipartOptions, getMultipartBoundary, isMultipartRequest, parseMultipart, parseMultipartRequest };
